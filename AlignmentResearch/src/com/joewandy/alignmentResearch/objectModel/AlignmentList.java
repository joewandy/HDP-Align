package com.joewandy.alignmentResearch.objectModel;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

import peakml.chemistry.PeriodicTable;


public class AlignmentList {

	private List<AlignmentRow> rows;
	private AlignmentFile data;
	private String id;
	
	/**
	 * Constructs a new simple alignment list
	 */
	public AlignmentList(String id) {
		this.rows = new ArrayList<AlignmentRow>();
		this.id = id;
	}
	
	/**
	 * Constructs a new simple alignment list, with rows initialised
	 * to each feature inside data
	 * @param data The data file
	 */
	public AlignmentList(AlignmentFile data) {

		this.rows = new ArrayList<AlignmentRow>();
		this.data = data;
		this.id = data.getFilenameWithoutExtension();
		
		// puts each feature inside data into a new row
		int rowId = 0;
		for (Feature f : data.getFeatures()) {
			AlignmentRow row = new AlignmentRow(rowId);
			row.addFeature(f);
			rowId++;
			rows.add(row);
		}
		
	}
	
	/**
	 * Constructs a new simple alignment list from entries inside inputFilePath
	 * Currently used for reading back the results from running SIMA as an external process
	 * @param inputFilePath Path to input file generated by other tools
	 * @param dataList List of all data files
	 * @throws FileNotFoundException 
	 */
	public AlignmentList(String inputFilePath, List<AlignmentFile> dataList, String id) throws FileNotFoundException {

		// we'll keep the alignment results here
		this.rows = new ArrayList<AlignmentRow>();
		
		// id is not really used for anything now
		this.id = id;
		
		// create a map of filename -> data, for convenience
		Map<String, AlignmentFile> map = new HashMap<String, AlignmentFile>();
		for (AlignmentFile data : dataList) {
			map.put(data.getFilenameWithoutExtension(), data);
		}
		
		File inputFile = new File(inputFilePath);
		Scanner in = new Scanner(inputFile);
		
		int currentId = Integer.MIN_VALUE;
		int prevId = currentId;
		boolean firstLine = true;
		
		Set<Feature> alignedFeatures = new HashSet<Feature>();
		int rowId = 0;
		while (in.hasNextLine()) {

			String line = in.nextLine();
			Scanner lineSplitter = new Scanner(line);

			// keep track of previous alignment group id, except for the first line read
			if (!firstLine) {
				prevId = currentId;
			}
			
			// first column in the line is the alignment group id
			currentId = lineSplitter.nextInt();
			
			// second column in the line is the originating file name
			String filename = lineSplitter.next();
			
			// must remember to remove extension to match the map key
			String fileNameWithOutExt = AlignmentFile.removeExtension(filename);
			AlignmentFile data = map.get(fileNameWithOutExt);
			
			// third column in the line is position of feature in data
			int featureIndex = lineSplitter.nextInt();
			Feature feature = null;
			try {
				feature = data.getFeatureByIndex(featureIndex);				
			} catch (IndexOutOfBoundsException e) {
				// invalid entry in the alignment result, skipping ...
				System.out.println("Invalid index " + featureIndex + " for " + data.getFilename() + " (" + data.getFeaturesCount() + ")");
				continue;
			} finally {
				lineSplitter.close();				
			}			
			
			// is this line the start of a new alignment group (row) ?
			if (!firstLine && prevId != currentId) {

				// starting a new alignment group, store the previously aligned features 
				AlignmentRow row = new AlignmentRow(rowId);
				row.addAlignedFeatures(alignedFeatures);
				rowId++;
				this.addRow(row);
				
				// keep the current feature in a new set
				alignedFeatures = new HashSet<Feature>();
				alignedFeatures.add(feature);				
				
			} else {
				
				// still continuing the previous alignment group
				alignedFeatures.add(feature);

			}
			
			firstLine = false;
			
		}
		in.close();
		
		// store all the remaining aligned features in the final row
		AlignmentRow row = new AlignmentRow(rowId);
		row.addAlignedFeatures(alignedFeatures);
		this.addRow(row);		
		
		System.out.println("Alignment entries loaded = " + this.rows.size() + " rows");

	}
	
	public List<AlignmentRow> getRows() {
		return rows;
	}
	
	public void addRow(AlignmentRow row) {
		rows.add(row);
	}

	public int getRowsCount() {
		return rows.size();
	}
	
	public AlignmentFile getData() {
		return data;
	}
	
	public String getId() {
		return id;
	}

	public Set<AlignmentRow> getRowsInRange(AlignmentRow reference, double massTol, double rtTol, 
			boolean usePpm) {
		
		Set<AlignmentRow> result = new HashSet<AlignmentRow>();

		double delta = 0;
		if (usePpm) {
			delta = PeriodicTable.PPM(reference.getAverageMz(), massTol);			
		} else {
			delta = massTol;			
		}

		double massLower = reference.getAverageMz() - delta;
		double massUpper = reference.getAverageMz() + delta;
		double rtLower = reference.getAverageRt() - rtTol;
		double rtUpper = reference.getAverageRt() + rtTol;		
		
		for (AlignmentRow toCheck : this.rows) {
			double massToCheck = toCheck.getAverageMz();
			double rtToCheck = toCheck.getAverageRt();
			if (inRange(massToCheck, massLower, massUpper)) {

				// in the mass range
				if (rtTol != -1) {
					
					// not in retention time range
					 if (inRange(rtToCheck, rtLower, rtUpper)) {
							result.add(toCheck);
					 }
					 
				} else {

					// not using retention time check
					result.add(toCheck);					
				
				}
			}
		}

		return result;
		
	}

	public Set<AlignmentRow> getRowsInRange(AlignmentRow reference, double massTol, boolean usePpm) {
		
		Set<AlignmentRow> result = new HashSet<AlignmentRow>();

		double delta = 0;
		if (usePpm) {
			delta = PeriodicTable.PPM(reference.getAverageMz(), massTol);			
		} else {
			delta = massTol;			
		}

		double massLower = reference.getAverageMz() - delta;
		double massUpper = reference.getAverageMz() + delta;
		
		for (AlignmentRow toCheck : this.rows) {
			double massToCheck = toCheck.getAverageMz();
			if (inRange(massToCheck, massLower, massUpper)) {
				result.add(toCheck);					
			}
		}

		return result;
		
	}
	
	public AlignmentRow getRowContaining(Feature feature) {
		for (AlignmentRow row : this.rows) {
			Set<Feature> rowFeatures = row.getFeatures();
			if (rowFeatures.contains(feature)) {
				return row;
			}
		}
		return null;
	}
	
	@Override
	public String toString() {
		return "SimpleAlignmentList [rows=" + rows.size() + ", data=" + data + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		AlignmentList other = (AlignmentList) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}

	private boolean inRange(double toCheck, double lowerRange, double upperRange) {
		// TODO: double comparison ?
		if (toCheck > lowerRange && toCheck < upperRange) {
			return true;
		} else {
			return false;
		}
	}

}
